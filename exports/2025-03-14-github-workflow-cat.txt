.github/FUNDING.yml
==== Content of .github/FUNDING.yml ====
github: Antony-at-Polycode
# paypal: https://www.paypal.com/donate/?hosted_button_id=Y8PK8XP3EJLWG
.github/workflows/publish.yml
==== Content of .github/workflows/publish.yml ====
# .github/workflows/publish.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Publish
run-name: 'Publish packages [${{ github.ref_name }}] [${{ github.event.head_commit.message }}]'
concurrency: agentic-lib

on:
  #push:
  #  branches:
  #    # When publishing from a branch, add branch name here, e,g, 'beta'
  #    - main
  #  paths:
  #    - '**/*.sh'
  #    - '**/*.js'
  #    - '**/*.json'
  #    - '**/*.yml'
  #    - '**/*.properties'
  #    - '!intentions/**'
  #    - '!conversations/**'
  #    - '!exports/**'
  #    - '!programs/**'
  #    - '!results/**'
  workflow_dispatch:
    inputs:
      versionIncrement:
        description: 'Select the Semantic Versioning segment to increment'
        required: true
        default: 'prerelease'
        type: choice
        options:
          - prerelease
          - patch
          - minor
          - major
          - premajor
          - preminor
          - prepatch

jobs:

  npm-test-and-run-main:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - run: npm install

      - name: test
        id: test
        shell: bash
        run: 'npm test'

      - name: main
        id: main
        shell: bash
        run: timeout 5m ${{ vars.MAIN_SCRIPT || 'npm run start' }}

  publish:
    needs:
      - npm-test-and-run-main
    permissions:
      contents: write
      packages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-publish.yml@2.6.6'
    with:
      versionIncrement: ${{ inputs.versionIncrement || 'prerelease' }}
      buildScript: 'npm run build'
      releaseNotes: 'Release incrment: ${{ inputs.versionIncrement }}.'
      npmAuthOrganisation: 'xn-intenton-z2a'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
.github/workflows/apply-fix.yml
==== Content of .github/workflows/apply-fix.yml ====
# .github/workflows/apply-fix.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Apply Fix on Fail
concurrency: agentic-lib
run-name: "Apply Fix on Fail [${{ github.ref_name }}]"

on:
  workflow_dispatch:
    inputs:
      target:
        description: 'The source file whose content is used in the resolution prompt. e.g. "src/lib/main.js"'
        required: false
        type: string
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file to run to validate the resolution. e.g. "tests/unit/main.test.js"'
        required: false
        type: string
        default: 'tests/unit/main.test.js'
      applyFixEvenIfTestsPass:
        description: 'Apply the fix even if the tests pass. e.g. true'
        required: false
        type: boolean
        default: false
      scanForBranches:
        description: 'Scan for branches matching the pattern. e.g. true'
        required: false
        type: boolean
        default: false
  workflow_run:
    workflows:
      - 'Tests'
    types:
      - completed
    branches:
      - agentic-lib-*
  schedule:
    #- cron: '0 */4 * * *' # schedule-1
    #- cron: '*/30 * * * *' # schedule-2
    - cron: '*/10 * * * *' # schedule-3

jobs:

  select-branch:
    runs-on: ubuntu-latest
    env:
      branchPrefix: 'agentic-lib-'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch all branches
        run: |
          git fetch --all
          git branch -r

      - name: determine-branch and auto-resolve merge conflicts
        id: determine
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync } = require('child_process');

            let branch;
            // Determine branch using schedule or ref
            if (context.eventName === "schedule" || context.eventName === "workflow_run" || "${{ inputs.scanForBranches }}" === "true") {
              core.info("Schedule event detected. Scanning for matching branches.");
              const branchesResp = await github.rest.repos.listBranches({
                owner: context.repo.owner,
                repo: context.repo.repo,
              });
              // Use the branch prefix from env (ensure process.env.branchPrefix is defined)
              const prefix = process.env.branchPrefix || "agentic-lib-";
              const matchingBranches = branchesResp.data
                .filter(b => new RegExp(`^${prefix}`).test(b.name))
                .map(b => b.name);
              core.info(`Matching branches: ${matchingBranches}`);
              branch = matchingBranches.length > 0 ? matchingBranches[0] : context.payload.repository?.default_branch || "main";
            } else {
              branch = context.ref.startsWith("refs/heads/") ? context.ref.substring("refs/heads/".length) : context.ref;
            }
            core.info(`Selected branch: ${branch}`);
            core.setOutput("branch", branch);

            if (branch === "main") {
              core.info("Main branch selected. Skipping auto-resolution.");
              core.setOutput("conflictsDetected", "false");
              core.setOutput("conflictsResolved", "true");
            } else {
              core.info("Detect and resolve merge conflicts between the selected branch and main.");
              execSync("git config --local user.email '${{ env.gitUserEmail }}'", { stdio: 'pipe' });
              execSync("git config --local user.name '${{ env.gitUserName }}'", { stdio: 'pipe' });
              execSync("git status -v", { stdio: 'pipe' });
              execSync(`git checkout origin/${branch}`, { stdio: 'pipe' });
              try {
                core.info("Fetching main branch...");
                execSync("git fetch origin main", { stdio: 'pipe' });
                core.info("Attempting a dry-run merge of main into the branch...");
                // Attempt dry-run merge without committing.
                execSync("git merge origin/main --no-commit --no-ff", { stdio: 'pipe' });
                core.info("No merge conflicts detected.");
                // Abort the merge attempt.
                //execSync("git merge --abort", { stdio: 'pipe' });
                //core.setOutput("conflictsDetected", "false");
                //core.setOutput("conflictsResolved", "true");
              } catch (err) {
                core.info(`Merge conflicts detected. ${err.message}`);
                core.setOutput("conflictsDetected", "true");
                try {
                  core.info("Attempting auto-resolution by accepting main's changes...");
                  // Auto-resolve by checking out the version from main for all conflicting files.
                  execSync("git checkout --theirs .", { stdio: 'pipe' });
                  execSync("git add .", { stdio: 'pipe' });
                  execSync("git commit -m 'Auto-resolved merge conflicts: accepted main changes'", { stdio: 'pipe' });
                  core.info("Auto-resolution succeeded.");
                  core.setOutput("conflictsResolved", "true");
                } catch (e) {
                  core.error("Auto-resolution failed: " + e.message);
                  core.setOutput("conflictsResolved", "false");
                }
              }
            }

            // Extract issue number from branch name using branchPrefix.
            const prefix = process.env.branchPrefix || "agentic-lib-";
            const issueNumberMatch = branch.match(new RegExp(`${prefix}issue-(\\d+)`));
            const issueNumber = issueNumberMatch ? issueNumberMatch[1] : '';
            core.setOutput("issueNumber", issueNumber);
            core.info(`Issue number: ${issueNumber}`);
    outputs:
      branch: ${{ steps.determine.outputs.branch }}
      issueNumber: ${{ steps.determine.outputs.issueNumber }}

  npm-test:
    needs: select-branch
    name: 'npm test with coverage'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.select-branch.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - run: npm install
      - run: npm run test:unit

  npm-build:
    needs: select-branch
    name: 'npm run build'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.select-branch.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - run: npm ci
      - run: npm run build

  npm-run:
    needs: select-branch
    name: 'npm run start'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.select-branch.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - run: npm ci
      - run: ${{ vars.MAIN_SCRIPT || 'npm run start' }}

  needs-fix:
    needs:
      - select-branch
      - npm-test
      - npm-build
      - npm-run
    if: >
      ${{ always() &&
         (
           needs.npm-test.result != 'success' ||
           needs.npm-build.result != 'success' ||
           needs.npm-run.result != 'success' ||
           inputs.applyFixEvenIfTestsPass == true
         )
      }}
    runs-on: ubuntu-latest
    steps:
      - name: set-needs-fix
        id: set-needs-fix
        uses: actions/github-script@v7
        with:
          script: |
            const npmTestResult = "${{ needs.npm-test.result }}";
            const npmBuildResult = "${{ needs.npm-build.result }}";
            const npmRunResult = "${{ needs.npm-run.result }}";
            const applyFixEvenIfTestsPass = "${{ inputs.applyFixEvenIfTestsPass }}" === "true";
            const needsFix = npmTestResult !== "success" || npmBuildResult !== "success" || npmRunResult !== "success" || applyFixEvenIfTestsPass;
            core.info(`Needs Fix: ${needsFix}`);
            core.setOutput("needsFix", needsFix);
    outputs:
      needsFix: ${{ steps.set-needs-fix.outputs.needsFix }}

  branch-for-fix:
    needs:
      - select-branch
      - needs-fix
    if: ${{ always() }}
    runs-on: ubuntu-latest
    env:
      branchPrefix: 'agentic-lib-'
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.select-branch.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: create-branch-if-required
        id: create-branch-if-required
        run: |
          if [[ '${{ needs.select-branch.outputs.branch }}' == 'main' && '${{ needs.needs-fix.outputs.needsFix }}' == 'true' ]] ; then
            echo 'Creating or force pushing to branch: ${{ env.branchPrefix }}fix-main'
            git switch --force-create '${{ env.branchPrefix }}fix-main'
            git push -v --force origin '${{ env.branchPrefix }}fix-main'
            echo 'branch=${{ env.branchPrefix }}fix-main' >> $GITHUB_OUTPUT
          else
            echo 'Retaining existing branch: ${{ needs.select-branch.outputs.branch }}'
            echo 'branch=${{ needs.select-branch.outputs.branch }}' >> $GITHUB_OUTPUT
          fi
    outputs:
      branch: ${{ steps.create-branch-if-required.outputs.branch }}

  apply-fix:
    needs:
      - branch-for-fix
      - branch-for-fix
      - npm-test
      - npm-build
      - npm-run
      - needs-fix
    if: ${{ always() && needs.needs-fix.outputs.needsFix == 'true' }}
    permissions:
      contents: write
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-apply-fix.yml@2.6.6'
    with:
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: 'README.md'
      contributingFile: 'CONTRIBUTING.md'
      dependenciesFile: 'package.json'
      formattingFile: '.prettierrc'
      lintingFile: 'eslint.config.js'
      buildScript: 'npm run build'
      testScript: 'npm test'
      mainScript: ${{ vars.MAIN_SCRIPT || 'npm run start' }}
      model: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      branch: ${{ needs.branch-for-fix.outputs.branch }}
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  npm-test-after-fix:
    needs:
      - branch-for-fix
      - npm-test
      - npm-build
      - npm-run
      - needs-fix
      - apply-fix
    if: ${{ always() && needs.needs-fix.outputs.needsFix == 'true' }}
    name: 'npm test with coverage'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.branch-for-fix.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ needs.branch-for-fix.outputs.branch }}
      - run: npm install
      - run: npm run test:unit

  npm-build-after-fix:
    needs:
      - branch-for-fix
      - npm-test
      - npm-build
      - npm-run
      - needs-fix
      - apply-fix
    if: ${{ always() && needs.needs-fix.outputs.needsFix == 'true' }}
    name: 'npm run build'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.branch-for-fix.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ needs.branch-for-fix.outputs.branch }}
      - run: npm ci
      - run: npm run build

  npm-run-after-fix:
    needs:
      - branch-for-fix
      - npm-test
      - npm-build
      - npm-run
      - needs-fix
      - apply-fix
    if: ${{ always() && needs.needs-fix.outputs.needsFix == 'true' }}
    name: 'npm run start'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.branch-for-fix.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ needs.branch-for-fix.outputs.branch }}
      - run: npm ci
      - run: ${{ vars.MAIN_SCRIPT || 'npm run start' }}

  needs-fix-after-fix:
    needs:
      - branch-for-fix
      - npm-test
      - npm-build
      - npm-run
      - needs-fix
      - apply-fix
      - npm-test-after-fix
      - npm-build-after-fix
      - npm-run-after-fix
    if: >
      ${{ always() &&
         (
           needs.npm-test-after-fix.result != 'success' ||
           needs.npm-build-after-fix.result != 'success' ||
           needs.npm-run-after-fix.result != 'success' ||
           inputs.applyFixEvenIfTestsPass == true
         )
      }}
    runs-on: ubuntu-latest
    steps:
      - name: set-needs-fix
        id: set-needs-fix
        uses: actions/github-script@v7
        with:
          script: |
            const applyFixEvenIfTestsPass = "${{ inputs.applyFixEvenIfTestsPass }}" === "true";
            const fixedFromTheBeginning = "${{ needs.needs-fix.outputs.needsFix }}" === "false";
            const anySkipped = "${{ needs.npm-test-after-fix.result == 'skipped' || needs.npm-build-after-fix.result == 'skipped' || needs.npm-run-after-fix.result == 'skipped' }}" === "true";
            const anyDidntSucceed = "${{ needs.npm-test-after-fix.result != 'success' || needs.npm-build-after-fix.result != 'success' || needs.npm-run-after-fix.result != 'success' }}" === "true";
            const readyToMerge = applyFixEvenIfTestsPass || fixedFromTheBeginning || !anySkipped && !anyDidntSucceed;
            
            core.setOutput("applyFixEvenIfTestsPass", applyFixEvenIfTestsPass);
            core.setOutput("fixedFromTheBeginning", fixedFromTheBeginning);
            core.setOutput("anySkipped", anySkipped);
            core.setOutput("anyDidntSucceed", anyDidntSucceed);
            core.setOutput("readyToMerge", readyToMerge);     
            
            core.info(`Apply fix even if tests pass: ${applyFixEvenIfTestsPass}`);
            core.info(`Fixed from the beginning: ${fixedFromTheBeginning}`);
            core.info(`Any skipped: ${anySkipped}`);
            core.info(`Any didn't succeed: ${anyDidntSucceed}`);
            core.info(`Ready to merge: ${readyToMerge}`);

    outputs:
      applyFixEvenIfTestsPass: ${{ steps.set-needs-fix.outputs.applyFixEvenIfTestsPass }}
      fixedFromTheBeginning: ${{ steps.set-needs-fix.outputs.fixedFromTheBeginning }}
      allSkipped: ${{ steps.set-needs-fix.outputs.allSkipped }}
      anyDidntSucceed: ${{ steps.set-needs-fix.outputs.anyDidntSucceed }}
      readyToMerge: ${{ steps.set-needs-fix.outputs.readyToMerge }}

  create-pr:
    needs:
      - select-branch
      - branch-for-fix
      - npm-test
      - npm-build
      - npm-run
      - apply-fix
      - needs-fix
      - npm-test-after-fix
      - npm-build-after-fix
      - npm-run-after-fix
      - needs-fix-after-fix
    if: ${{ always() && needs.branch-for-fix.outputs.branch != 'main' && needs.needs-fix-after-fix.outputs.readyToMerge == 'true' }}
    permissions:
      contents: write
      packages: write
      issues: write
      pull-requests: write
      checks: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-create-pr.yml@2.6.6'
    with:
      branch: "${{ needs.branch-for-fix.outputs.branch }}"
      baseBranch: 'main'
      gitCommitMessage: "${{ needs.apply-fix.outputs.message }} (fixes #${{ needs.select-branch.outputs.issueNumber }})"
      label: 'automerge'
.github/workflows/truncate-workflow-history.yml
==== Content of .github/workflows/truncate-workflow-history.yml ====
# .github/workflows/issue-creator.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: âˆž Truncate Workflow Runs
concurrency: truncate-workflow-runs

on:
  workflow_dispatch:
  schedule:
    #- cron: '0 0 */7 * *' # schedule-1
    #- cron: '0 0 * * *' # schedule-2
    - cron: '0 0 * * *' # schedule-3

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Clean up old workflow runs and artifacts
        uses: actions/github-script@v7
        with:
          script: |
            // Set retention period (in days)
            const retentionDays = 7;
            const cutoffDate = new Date(Date.now() - retentionDays * 24 * 60 * 60 * 1000);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const perPage = 100;
            let runsDeleted = 0;
            let artifactsDeleted = 0;

            console.log(`Deleting workflow runs and artifacts older than ${retentionDays} days (before ${cutoffDate.toISOString()})...`);

            // Delete old workflow runs
            let page = 1;
            while (true) {
              const runsResponse = await github.rest.actions.listWorkflowRunsForRepo({
                owner,
                repo,
                per_page: perPage,
                page
              });
              const runs = runsResponse.data.workflow_runs;
              if (runs.length === 0) break;
              for (const run of runs) {
                const runCreatedAt = new Date(run.created_at);
                if (runCreatedAt < cutoffDate) {
                  try {
                    await github.rest.actions.deleteWorkflowRun({
                      owner,
                      repo,
                      run_id: run.id
                    });
                    console.log(`Deleted workflow run ${run.id} (created at ${run.created_at})`);
                    runsDeleted++;
                  } catch (error) {
                    console.error(`Failed to delete run ${run.id}: ${error.message}`);
                  }
                }
              }
              page++;
            }
            console.log(`Total workflow runs deleted: ${runsDeleted}`);

            // Delete old artifacts
            page = 1;
            while (true) {
              const artifactsResponse = await github.rest.actions.listArtifactsForRepo({
                owner,
                repo,
                per_page: perPage,
                page
              });
              const artifacts = artifactsResponse.data.artifacts;
              if (artifacts.length === 0) break;
              for (const artifact of artifacts) {
                const artifactCreatedAt = new Date(artifact.created_at);
                if (artifactCreatedAt < cutoffDate) {
                  try {
                    await github.rest.actions.deleteArtifact({
                      owner,
                      repo,
                      artifact_id: artifact.id
                    });
                    console.log(`Deleted artifact ${artifact.id} (created at ${artifact.created_at})`);
                    artifactsDeleted++;
                  } catch (error) {
                    console.error(`Failed to delete artifact ${artifact.id}: ${error.message}`);
                  }
                }
              }
              page++;
            }
            console.log(`Total artifacts deleted: ${artifactsDeleted}`);

            return `Cleanup complete. Deleted ${runsDeleted} runs and ${artifactsDeleted} artifacts.`;
          result-encoding: string
.github/workflows/stats.yml
==== Content of .github/workflows/stats.yml ====
# .github/workflows/stats.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: âˆž Stats

on:
  workflow_dispatch:
  schedule:
    #- cron: '0 */2 * * *' # schedule-1
    #- cron: '*/15 * * * *' # schedule-2
    - cron: '*/5 * * * *' # schedule-3

jobs:
  generate-site:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - run: npm install

      - name: engine
        id: engine
        shell: bash
        run: |
          engine=$(grep '^[[:space:]]*- cron:.*#' .github/workflows/stats.yml | sed 's/^[[:space:]]*- cron:.*# //g')
          echo "engine=${engine}"
          echo "engine=${engine}" >> $GITHUB_OUTPUT

      - name: Generate statistics page
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            // Helper: truncate string to max length with ellipsis.
            function truncate(str, max) {
              return str.length > max ? str.substring(0, max) + "..." : str;
            }

            const now = new Date();
            const { owner, repo } = context.repo;
            core.info(`Gathering stats for ${owner}/${repo}...`);

            // Open issues count (up to 256)
            const issuesResp = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: "open",
              per_page: 256
            });
            const openIssues = issuesResp.data.length;
            core.info(`Open issues: ${openIssues}`);

            // Issues closed in last hour and last 24 hours.
            const sinceOneHour = new Date(now.getTime() - (60 * 60 * 1000)).toISOString();
            const closedHourResp = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: "closed",
              since: sinceOneHour,
              per_page: 256
            });
            const issuesClosedLastHour = closedHourResp.data.length;
            const sinceOneDay = new Date(now.getTime() - (24 * 60 * 60 * 1000)).toISOString();
            const closedDayResp = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: "closed",
              since: sinceOneDay,
              per_page: 256
            });
            const issuesClosedLastDay = closedDayResp.data.length;

            // Open pull requests with age annotation (in minutes).
            const pullsResp = await github.rest.pulls.list({
              owner,
              repo,
              state: "open",
              per_page: 256
            });
            const prDetails = pullsResp.data.map(pr => {
              const createdAt = new Date(pr.created_at);
              const ageMinutes = Math.floor((now - createdAt) / (1000 * 60));
              return `[${ageMinutes}m] ${pr.title}`;
            });
            const openPRs = prDetails.length;
            core.info(`Open PRs (${openPRs}): ${prDetails.join('; ')}`);

            // Repository push details, converted to minutes.
            const repoResp = await github.rest.repos.get({ owner, repo });
            const pushedAt = new Date(repoResp.data.pushed_at);
            const diffMinutes = Math.floor((now - pushedAt) / (1000 * 60));

            const mainBranchResp = await github.rest.repos.getBranch({ owner, repo, branch: "main" });
            const mainPushedAt = new Date(mainBranchResp.data.commit.commit.author.date);
            const diffMinutesMain = Math.floor((now - mainPushedAt) / (1000 * 60));

            // Commits in the last hour and last day.
            const commitsLastHourResp = await github.rest.repos.listCommits({
              owner,
              repo,
              since: sinceOneHour,
              per_page: 256
            });
            const commitsLastHour = commitsLastHourResp.data.length;
            const commitsLastDayResp = await github.rest.repos.listCommits({
              owner,
              repo,
              since: sinceOneDay,
              per_page: 256
            });
            const commitsLastDay = commitsLastDayResp.data.length;

            // Last 5 commit messages from main with timestamp (HH:MM) and truncated.
            const lastFiveCommitsResp = await github.rest.repos.listCommits({
              owner,
              repo,
              sha: "main",
              per_page: 5
            });
            const lastFiveCommitMessages = lastFiveCommitsResp.data.map(commit => {
              const commitDate = new Date(commit.commit.author.date);
              const hh = commitDate.getHours().toString().padStart(2, '0');
              const mm = commitDate.getMinutes().toString().padStart(2, '0');
              const truncatedMsg = truncate(commit.commit.message, 64);
              return `[${hh}:${mm}] - ${truncatedMsg}`;
            });

            // Branches excluding "main" and "github-pages", with last commit time (in minutes).
            const branchesResp = await github.rest.repos.listBranches({
              owner,
              repo,
              per_page: 256
            });
            const branchData = branchesResp.data.filter(branch => branch.name !== "main" && branch.name !== "github-pages");
            const branchDetails = await Promise.all(branchData.map(async branch => {
              const branchResp = await github.rest.repos.getBranch({ owner, repo, branch: branch.name });
              const lastCommitDate = new Date(branchResp.data.commit.commit.author.date);
              const minutesSinceLastCommit = Math.floor((now - lastCommitDate) / (1000 * 60));
              // For lack of branch creation time, duplicate the last commit time.
              return `[${minutesSinceLastCommit}m/${minutesSinceLastCommit}m] ${branch.name}`;
            }));
            const branchCount = branchDetails.length;

            // Additional metrics: Average PR age and placeholder test status.
            const averagePRAge = openPRs > 0 ? Math.floor(prDetails.reduce((sum, prText) => {
              const match = prText.match(/^\[(\d+)m\]/);
              return sum + (match ? parseInt(match[1]) : 0);
            }, 0) / openPRs) : 0;
            const testStatus = "PASS"; // Placeholder (if tests info available, include it)
            const testsLastPassedMinutes = 15; // Placeholder

            const html = `
              <!DOCTYPE html>
              <html lang="en">
              <head>
              <meta charset="UTF-8">
              <title>${repo} stats</title>
              <style>
                body { font-family: Arial, sans-serif; margin: 2em; background-color: #f9f9f9; color: #333; }
                h1 { font-size: 1.5em; font-family: monospace; }
                section { margin-bottom: 1em; }
                ul { list-style: none; padding: 0; }
                li { margin: 0.5em 0; }
                .label { font-weight: bold; }
                footer { margin-top: 2em; font-size: 0.9em; color: #777; }
              </style>
              </head>
              <body>
                <header>
                  <h1>${repo}</h1>
                </header>
                <section>
                  <p><span class="label">Open Pull Requests (${openPRs}):</span> ${prDetails.join('; ') || 'None'}</p>
                </section>
                <section>
                  <p><span class="label">Branches (${branchCount}):</span> ${branchDetails.join(', ') || 'None'}</p>
                </section>
                <section>
                  <p><span class="label">Open Issues:</span> ${openIssues}</p>
                  <p><span class="label">Issues closed in last hour:</span> ${issuesClosedLastHour}</p>
                  <p><span class="label">Issues closed in last 24 hours:</span> ${issuesClosedLastDay}</p>
                </section>
                <section>
                  <p><span class="label">Engine:</span> ${{ steps.engine.outputs.engine }}</p>
                </section>
                <section>
                  <p><span class="label">Minutes since push anywhere:</span> ${diffMinutes}</p>
                  <p><span class="label">Minutes since push to main:</span> ${diffMinutesMain}</p>
                </section>
                <section>
                  <p><span class="label">Commits to main last hour:</span> ${commitsLastHour}</p>
                  <p><span class="label">Commits to main last day:</span> ${commitsLastDay}</p>
                </section>
                <section>
                  <p><span class="label">Last 5 commit messages from main:</span></p>
                  <ul>
                    ${lastFiveCommitMessages.map(msg => `<li>${msg}</li>`).join('')}
                  </ul>
                </section>
                <section>
                  <p>
                    <a href="https://github.com/${owner}/${repo}" target="_blank">repository ðŸ”—</a> - 
                    <a href="https://${owner}.github.io/${repo}/index.html" target="_blank">site ðŸ”—</a> - 
                    <a href="https://${owner}.github.io/${repo}/latest.html" target="_blank">stats ðŸ”—</a> - 
                    <a href="https://${owner}.github.io/${repo}/all.html" target="_blank">all stats ðŸ”—</a>
                  </p>
                </section>
                <footer>
                  <p>Generated on ${now.toISOString()}</p>
                </footer>
              </body>
              </html>
            `;
            
            // Ensure the output directory exists.
            const outputDir = "public";
            if (!fs.existsSync(outputDir)) {
              fs.mkdirSync(outputDir);
            }
            const outputPath = path.join(outputDir, "latest.html");
            fs.writeFileSync(outputPath, html, "utf8");
            core.info(`Static site generated at ${outputPath}.`);
            core.setOutput("sitePath", outputPath);

      - name: Generate index page
        shell: bash
        run: |
          ./scripts/md-to-html.js < README.md > public/index.agentic-lib.html
          cat public/index.agentic-lib.html | sed 's/agentic-lib/${{ github.event.repository.name }}/g' > public/index.html

      - name: Generate unique filename for this version
        id: uniqueFile
        run: |
          echo "[INFO] Generating a unique filename..."
          unique=$(date +%Y%m%d%H%M%S)-$(uuidgen).html
          cp public/latest.html "public/${unique}"
          echo "uniqueFile=${unique}" >> $GITHUB_OUTPUT
          echo "[INFO] Unique file created: public/${unique}"

      - name: Upload generated site as artifact
        uses: actions/upload-artifact@v4
        with:
          name: site
          path: 'public'

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: 'public'
          publish_branch: github-pages
          keep_files: true
          enable_jekyll: 'true'

      - name: Output published URLs
        run: |
          echo "[INFO] Determining GitHub Pages URL..."
          # GitHub Pages URL typically: https://<owner>.github.io/<repo>/
          repoName=${{ github.event.repository.name }}
          owner=${{ github.repository_owner }}
          baseUrl="https://${owner}.github.io/${repoName}"
          latestUrl="${baseUrl}/latest.html"
          uniqueFile=$(echo "${{ steps.uniqueFile.outputs.uniqueFile }}" | tr -d '\n')
          uniqueUrl="${baseUrl}/${uniqueFile}"
          pwd
          echo "public:"
          ls -larth "public"
          echo "public/latest.html:"
          ls -larth "public/latest.html"
          echo "public/${uniqueFile}:"
          ls -larth "public/${uniqueFile}"
          echo "::notice:: latestUrl: ${latestUrl}"
          echo "::notice:: uniqueUrl: ${uniqueUrl}"
          echo "latestUrl=${latestUrl}" >> $GITHUB_OUTPUT
          echo "uniqueUrl=${uniqueUrl}" >> $GITHUB_OUTPUT
.github/workflows/test.yml
==== Content of .github/workflows/test.yml ====
# .github/workflows/test.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Tests
run-name: 'Tests [${{ github.ref_name }}] [${{ github.event.head_commit.message }}]'

on:
  push:
    paths:
      - '**/*.sh'
      - '**/*.js'
      - '**/*.json'
      - '**/*.yml'
      - '**/*.properties'
      - '!exports/**'
  workflow_dispatch:
  workflow_run:
    workflows:
      - "Automerge"
    types:
      - completed
  schedule:
    #- cron: '45 */6 * * *' # schedule-1
    #- cron: '45 */4 * * *' # schedule-2
    - cron: '0 * * * *' # schedule-3


jobs:


  npm-test:
    name: 'npm test'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - run: npm install

      - run: npm test

  npm-unit-test:
    name: 'npm unit test with coverage'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - run: npm install

      - run: npm run test:unit

  npm-build-test-and-run-main:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - run: npm install

      - name: build
        id: build
        shell: bash
        run: 'npm run build'

      - name: test
        id: test
        shell: bash
        run: 'npm test'

      - name: main
        id: main
        shell: bash
        run: timeout 5m ${{ vars.MAIN_SCRIPT || 'npm run start' }}.github/workflows/issue-creator.yml
==== Content of .github/workflows/issue-creator.yml ====
# .github/workflows/issue-creator.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Create Issue
concurrency: create-issue
run-name: "Create Issue"

on:
  workflow_dispatch:
    inputs:
      target:
        description: 'An asset (e.g. source file) to reference in the issue. e.g. "src/lib/main.js"'
        required: false
        type: string
        default: 'src/lib/main.js'
      issueTitle:
        description: 'Text to drive the issue title (if "house choice", a currently random prompt will be selected). e.g. "Make a small improvement."'
        required: false
        type: string
        default: 'house choice'
  schedule:
    #- cron: '0 4 * * *' # schedule-1
    #- cron: '0 */2 * * *' # schedule-2
    - cron: '*/15 * * * *' # schedule-3

jobs:

  extract-options:
    runs-on: ubuntu-latest
    outputs:
      houseChoiceOptions: ${{ steps.extract.outputs.houseChoiceOptions }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Parse Issue House Choice Options from CONTRIBUTING.md
        id: extract
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let houseChoiceOptions = '';
            const filePath = './CONTRIBUTING.md';
            if (fs.existsSync(filePath)) {
              const content = fs.readFileSync(filePath, 'utf8');
              const lines = content.split('\n');
              let capture = false;
              let options = [];
            
              // Look for the section header; case-insensitive match for "Issue House Choice Options"
              for (const line of lines) {
                if (line.trim().match(/^##\s+Issue House Choice Options\s*$/i)) {
                  capture = true;
                  continue;
                }
                // Stop capturing if a new heading appears
                if (capture && line.trim().match(/^##\s+/)) {
                  break;
                }
                if (capture) {
                  // Parse only bullet list items (lines starting with "- ")
                  const bulletMatch = line.trim().match(/^-\s+(.*)$/);
                  if (bulletMatch) {
                    options.push(bulletMatch[1].trim());
                  }
                }
              }
              if (options.length > 0) {
                houseChoiceOptions = options.join(' || ');
              }
            }
            core.setOutput('houseChoiceOptions', houseChoiceOptions);
            core.info(`houseChoiceOptions: ${houseChoiceOptions}`);

  create-issue:
    needs:
      - extract-options
    permissions:
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-create-issue.yml@2.6.6'
    with:
      issueTitle: ${{ inputs.issueTitle || 'house choice' }}
      houseChoiceOptions: ${{ needs.extract-options.outputs.houseChoiceOptions }}
.github/workflows/issue-worker.yml
==== Content of .github/workflows/issue-worker.yml ====
# .github/workflows/issue-worker.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Issue Worker
concurrency: agentic-lib
run-name: "Issue Worker [${{ github.ref_name }}]"

on:
  workflow_dispatch:
    inputs:
      issueNumber:
        description: 'The issue number to resolve. If not provided, the workflow will select one based on label. e.g. "123"'
        required: false
        type: string
        default: ''
      target:
        description: 'The source file whose content is used in the resolution prompt. e.g. "src/lib/main.js"'
        required: false
        type: string
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file to run to validate the resolution. e.g. "tests/unit/main.test.js"'
        required: false
        type: string
        default: 'tests/unit/main.test.js'
      selectionLabel:
        description: 'Label used to filter issues for resolution. e.g. "automated"'
        required: false
        type: string
        default: 'automated'
  workflow_run:
    workflows:
      - "Create Issue"
      - "Linting"
    types:
      - completed
  schedule:
    #- cron: '15 */4 * * *' # schedule-1
    #- cron: '*/30 * * * *' # schedule-2
    - cron: '*/10 * * * *' # schedule-3

jobs:

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-select-issue.yml@2.6.6'
    with:
      issueNumber: ${{ inputs.issueNumber || '' }}
      selectionLabel: ${{ inputs.selectionLabel || 'automated' }}
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  needs-resolution:
    runs-on: ubuntu-latest
    steps:
      - name: todo
        shell: bash
        run: |
          echo "TODO: Check if this issue has been resolved already by examining the current state and recent commits"

  npm-test:
    name: 'npm test with coverage'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - run: npm install
      - run: npm run test:unit

  npm-build:
    name: 'npm run build'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - run: npm ci
      - run: npm run build

  npm-run:
    name: 'npm run start'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - run: npm ci
      - run: ${{ vars.MAIN_SCRIPT || 'npm run start' }}

  check-branch:
    needs:
      - select-issue
      - npm-test
      - npm-build
      - npm-run
      - needs-resolution
    if: ${{ needs.select-issue.outputs.issueNumber != '' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    env:
      branchPrefix: 'agentic-lib-'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}
      - name: Ensure there isn't already a branch for this prefix
        shell: bash
        run: |
          git fetch origin
          if git branch -r | grep -q 'origin/${{ env.branchPrefix }}'; then
            echo "A branch with the prefix '${{ env.branchPrefix }}' already exists."
            exit 1
          else
            echo "No existing branch with the prefix found."
          fi

  apply-issue-resolution:
    needs:
      - select-issue
      - needs-resolution
      - npm-test
      - npm-build
      - npm-run
      - check-branch
    if: ${{ needs.select-issue.outputs.issueNumber != '' }}
    permissions:
      contents: write
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-apply-issue-resolution.yml@2.6.6'
    with:
      issueNumber: ${{ needs.select-issue.outputs.issueNumber }}
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: 'README.md'
      contributingFile: 'CONTRIBUTING.md'
      dependenciesFile: 'package.json'
      formattingFile: '.prettierrc'
      lintingFile: 'eslint.config.js'
      branchPrefix: 'agentic-lib-issue-'
      buildScript: 'npm run build'
      testScript: 'npm test'
      mainScript: ${{ vars.MAIN_SCRIPT || 'npm run start' }}
      model: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  npm-test-after-issue-resolution:
    needs:
      - needs-resolution
      - npm-test
      - npm-build
      - npm-run
      - apply-issue-resolution
    name: 'npm test with coverage'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.apply-issue-resolution.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ needs.apply-issue-resolution.outputs.branch }}
      - run: npm install
      - run: npm run test:unit

  npm-build-after-issue-resolution:
    needs:
      - needs-resolution
      - npm-test
      - npm-build
      - npm-run
      - apply-issue-resolution
    name: 'npm run build'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.apply-issue-resolution.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ needs.apply-issue-resolution.outputs.branch }}
      - run: npm ci
      - run: npm run build

  npm-run-after-issue-resolution:
    needs:
      - needs-resolution
      - npm-test
      - npm-build
      - npm-run
      - apply-issue-resolution
    name: 'npm run start'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.apply-issue-resolution.outputs.branch }}
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"
      - name: Get latest from remote
        run: |
          git config --local user.email "${{ env.gitUserEmail }}"
          git config --local user.name "${{ env.gitUserName }}"
          git pull --ff-only origin ${{ needs.apply-issue-resolution.outputs.branch }}
      - run: npm ci
      - run: ${{ vars.MAIN_SCRIPT || 'npm run start' }}

  needs-fix-after-issue-resolution:
    needs:
      - needs-resolution
      - npm-test
      - npm-build
      - npm-run
      - apply-issue-resolution
      - npm-test-after-issue-resolution
      - npm-build-after-issue-resolution
      - npm-run-after-issue-resolution
    if: >
      ${{ always() &&
         (
           needs.npm-test-after-issue-resolution.result != 'success' ||
           needs.npm-build-after-issue-resolution.result != 'success' ||
           needs.npm-run-after-issue-resolution.result != 'success'
         )
      }}
    runs-on: ubuntu-latest
    steps:
      - name: set-needs-fix
        id: set-needs-fix
        uses: actions/github-script@v7
        with:
          script: |
            const anySkipped = "${{ needs.npm-test-after-issue-resolution.result == 'skipped' || needs.npm-build-after-issue-resolution.result == 'skipped' || needs.npm-run-after-issue-resolution.result == 'skipped' }}" === "true";
            const anyDidntSucceed = "${{ needs.npm-test-after-issue-resolution.result != 'success' || needs.npm-build-after-issue-resolution.result != 'success' || needs.npm-run-after-issue-resolution.result != 'success' }}" === "true";
            const readyToMerge = !anySkipped && !anyDidntSucceed;
            
            core.setOutput("anySkipped", anySkipped);
            core.setOutput("anyDidntSucceed", anyDidntSucceed);
            core.setOutput("readyToMerge", readyToMerge);     
            
            core.info(`Any skipped: ${anySkipped}`);
            core.info(`Any didn't succeed: ${anyDidntSucceed}`);
            core.info(`Ready to merge: ${readyToMerge}`);

    outputs:
      allSkipped: ${{ steps.set-needs-fix.outputs.allSkipped }}
      anyDidntSucceed: ${{ steps.set-needs-fix.outputs.anyDidntSucceed }}
      readyToMerge: ${{ steps.set-needs-fix.outputs.readyToMerge }}

  create-pr:
    needs:
      - select-issue
      - needs-resolution
      - apply-issue-resolution
      - needs-fix-after-issue-resolution
    if: ${{ needs.select-issue.outputs.issueNumber != '' && needs.apply-issue-resolution.outputs.fixApplied == 'true' && needs.needs-fix-after-issue-resolution.outputs.readyToMerge == 'true' }}
    permissions:
      contents: write
      packages: write
      issues: write
      pull-requests: write
      checks: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-create-pr.yml@2.6.6'
    with:
      branch: '${{ needs.apply-issue-resolution.outputs.branch }}'
      baseBranch: 'main'
      gitCommitMessage: "${{ needs.apply-issue-resolution.outputs.message }} (fixes #${{ needs.select-issue.outputs.issueNumber }})"
      label: 'automerge'
.github/workflows/automerge.yml
==== Content of .github/workflows/automerge.yml ====
# .github/workflows/automerge.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Automerge
concurrency: agentic-lib
run-name: "Automerge [${{ github.ref_name }}]"

on:
  pull_request:
  check_suite:
  workflow_dispatch:
  workflow_run:
    workflows:
      - "Issue Worker"
      - "Update"
    types:
      - completed
  schedule:
    #- cron: '30 */4 * * *' # schedule-1
    #- cron: '*/30 * * * *' # schedule-2
    - cron: '*/10 * * * *' # schedule-3

env:
  pullRequestLabel: 'automerge'

jobs:
  label:
    runs-on: ubuntu-latest
    steps:
      - name: echo
        shell: bash
        run: |
          echo "Label: ${{ env.pullRequestLabel }}"
    outputs:
      pullRequestLabel: ${{ env.pullRequestLabel }}

  echo-event:
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo 'Triggered by: ${{ github.event_name }}'

  pull-request-event:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Triggered by: pull_request"

  check-suite-event:
    if: github.event_name == 'check_suite'
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Triggered by: check_suite"

  schedule-event:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Triggered by: schedule"

  workflow-dispatch-event:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Triggered by: workflow_dispatch"

  workflow-run-event:
    if: github.event_name == 'workflow_run'
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Triggered by: workflow_run"

  pr:
    needs: label
    if: github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, needs.label.outputs.pullRequestLabel )
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-automerge-find-pr-from-pull-request.yml@2.6.6'

  cs:
    if: github.event_name == 'check_suite' && github.event.check_suite.conclusion == 'success'
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-automerge-find-pr-in-check-suite.yml@2.6.6'

  ls:
    needs: label
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_run'
    runs-on: ubuntu-latest
    steps:
      - name: Determine pull request number
        id: get-pull
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let pullRequest;
            let pullNumber;
            const { data: pullRequests } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 1,
              sort: 'created',
              direction: 'asc'
            });
            if (pullRequests.length > 0) {
              const filteredPRs = pullRequests.filter(pr => pr.labels.some(label => label.name === '${{ needs.label.outputs.pullRequestLabel }}' ));
              if (filteredPRs.length > 0) {
                pullRequest = filteredPRs[0];
                core.info(`Found open pull request with label ${{ needs.label.outputs.pullRequestLabel }}: #${pullRequest.number}.`);
                core.info(JSON.stringify(pullRequest));
              } else {
                core.info(`No open pull request found with label ${{ needs.label.outputs.pullRequestLabel }}.`);
                pullRequest = null;
              }
            } else {
              pullRequest = null;
              core.info('No open pull requests found.');
            }
            if (pullRequests.length > 0) {
              pullNumber = pullRequests[0].number;
            } else {
              pullNumber = '';
              core.info('No open pull requests found.');
            }
            core.info(`pullNumber: ${pullNumber}`);
            core.setOutput('pullNumber', pullNumber);
          result-encoding: string
    outputs:
      pullNumber: ${{ steps.get-pull.outputs.pullNumber }}

  merge-check:
    if: ${{ always() }}
    needs:
      - pr
      - cs
      - ls
    runs-on: ubuntu-latest
    steps:
      - name: set-outputs
        id: set-outputs
        uses: actions/github-script@v7
        with:
          script: |
            // Merge outputs from pr-check, cs-check, and determine-ls.
            // Only one of pr-check or cs-check should have run.
            let prMerged = '${{ needs.pr.outputs.prMerged || needs.cs.outputs.prMerged || 'false' }}';
            let pullNumber = '${{ needs.pr.outputs.pullNumber || needs.cs.outputs.pullNumber || needs.ls.outputs.pullNumber }}';
            let shouldSkipMerge = '${{ needs.pr.outputs.shouldSkipMerge || needs.cs.outputs.shouldSkipMerge || 'false' }}';
            core.setOutput('prMerged', `${prMerged}`);
            core.setOutput('pullNumber', `${pullNumber}`);
            core.setOutput('shouldSkipMerge', `${shouldSkipMerge}`);
            core.info(`prMerged: '${prMerged}'`);
            core.info(`pullNumber: '${pullNumber}'`);
            core.info(`shouldSkipMerge: '${shouldSkipMerge}'`);
          result-encoding: string
    outputs:
      prMerged: ${{ steps.set-outputs.outputs.prMerged }}
      pullNumber: ${{ steps.set-outputs.outputs.pullNumber }}
      shouldSkipMerge: ${{ steps.set-outputs.outputs.shouldSkipMerge }}

  label-issue-after-check-pr:
    needs:
      - merge-check
    if: needs.merge-check.outputs.prMerged == 'true' && needs.merge-check.outputs.pullNumber != ''
    permissions:
      contents: write
      pull-requests: read
      issues: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-automerge-label-issue.yml@2.6.6'
    with:
      pullNumber: '${{ needs.merge-check.outputs.pullNumber }}'
      branchPrefix: 'agentic-lib-issue-'

  automerge:
    needs:
      - merge-check
    if: always() && needs.merge-check.outputs.shouldSkipMerge != 'true' && needs.merge-check.outputs.pullNumber != ''
    permissions:
      contents: write
      pull-requests: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-automerge-merge-pr.yml@2.6.6'
    with:
      pullNumber: '${{ needs.merge-check.outputs.pullNumber }}'

  label-issue-after-automerge:
    needs:
      - merge-check
      - automerge
    if: always() && ( needs.automerge.outputs.prMerged == 'true' && needs.merge-check.outputs.pullNumber != '' )
    permissions:
      contents: write
      issues: write
      pull-requests: read
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-automerge-label-issue.yml@2.6.6'
    with:
      pullNumber: ${{ needs.automerge.outputs.prMerged == 'true' && needs.merge-check.outputs.pullNumber || '' }}
      branchPrefix: 'agentic-lib-issue-'
.github/workflows/issue-for-linting.yml
==== Content of .github/workflows/issue-for-linting.yml ====
# .github/workflows/issue-for-linting.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Linting
concurrency: agentic-lib
run-name: "Linting [${{ github.ref_name }}]"

on:
  workflow_dispatch:
  schedule:
    #- cron: '15 4 */7 * *' # schedule-1
    #- cron: '15 4 * * *' # schedule-2
    - cron: '15 4 * * *' # schedule-3

jobs:

  linting:
    permissions:
      contents: write
      packages: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-run-script-and-commit-to-branch.yml@2.6.6'
    with:
      #script: 'npm run linting "." -- --max-warnings=10'
      script: 'npm run linting src/lib/main.js tests/unit/main.test.js'
      sarifScript: 'npm run linting-json --silent src/lib/main.js tests/unit/main.test.js'
      testScript: 'npm test'

  create-issue:
    needs:
      - linting
    if: ${{ needs.linting.outputs.fixStillRequired == 'true' || needs.linting.outputs.fixStillRequired == true || needs.linting.outputs.remainingResultsCount != '0' }}
    permissions:
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-create-issue.yml@2.6.6'
    with:
      issueTitle: 'Resolve issues in output from running: npm run linting-fix "." -- --max-warnings=10'
      issueBody: ${{ needs.linting.outputs.scriptOutput }}
.github/workflows/update.yml
==== Content of .github/workflows/update.yml ====
# .github/workflows/update.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Update
concurrency: agentic-lib
run-name: "Update [${{ github.ref_name }}]"

on:
  repository_dispatch:
    types: [package-published]
  schedule:
    #- cron: '30 7 */7 * *' # schedule-1
    #- cron: '30 7 * * *' # schedule-2
    - cron: '30 7 * * *' # schedule-3

  workflow_dispatch:
    inputs:
      upgradeTarget:
        description: 'Select the type of update to run'
        type: choice
        default: 'minor'
        required: false
        options:
          - greatest
          - latest
          - newest
          - patch
          - minor
          - semver

jobs:

  check-branch:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    env:
      branchPrefix: 'agentic-lib-'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}
      - name: Ensure there isn't already a branch for this prefix
        shell: bash
        run: |
          git fetch origin
          if git branch -r | grep -q 'origin/${{ env.branchPrefix }}'; then
            echo "A branch with the prefix '${{ env.branchPrefix }}' already exists."
            exit 1
          else
            echo "No existing branch with the prefix found."
          fi

  update:
    needs:
      - check-branch
    permissions:
      contents: write
      pull-requests: write
      id-token: write
      packages: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-update.yml@2.6.6'
    with:
      buildScript: 'npm run build'
      testScript: 'npm test'
      mainScript: ${{ vars.MAIN_SCRIPT || 'npm run start' }}
      upgradeTarget: ${{ inputs.upgradeTarget || 'patch' }}
      branch: 'agentic-lib-update'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
      gitCommitMessage: 'chore: dependency updates'

  create-pr:
    needs:
      - update
    if: ${{ needs.update.outputs.updatedFiles == 'true' }}
    permissions:
      contents: write
      packages: write
      issues: write
      pull-requests: write
      checks: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-create-pr.yml@2.6.6'
    with:
      branch: 'agentic-lib-update'
      baseBranch: 'main'
      gitCommitMessage: 'chore: dependency updates'
      label: 'automerge'
.github/workflows/issue-reviewer.yml
==== Content of .github/workflows/issue-reviewer.yml ====
# .github/workflows/issue-reviewer.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: Review Issue
run-name: "Review Issue [${{ github.ref_name }}]"

on:
  workflow_dispatch:
    inputs:
      issueNumber:
        description: 'The issue number to review. If not provided, the workflow will select one based on label. e.g. "123"'
        required: false
        type: string
        default: ''
      selectionLabel:
        description: 'Label used to filter issues for review. e.g. "merged"'
        required: false
        type: string
        default: 'merged'
      target:
        description: 'The source file whose content was used in the resolution prompt. e.g. "src/lib/main.js"'
        required: false
        type: string
        default: 'src/lib/main.js'
      testFile:
        description: 'The test file to run to validate the resolution. e.g. "tests/unit/main.test.js"'
        required: false
        type: string
        default: 'tests/unit/main.test.js'
  workflow_run:
    workflows:
      - "Automerge"
    types:
      - completed
  schedule:
    #- cron: '45 */6 * * *' # schedule-1
    #- cron: '*/15 * * * *' # schedule-2
    - cron: '*/5 * * * *' # schedule-3

jobs:

  select-issue:
    permissions:
      issues: read
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-select-issue.yml@2.6.6'
    with:
      issueNumber: ${{ inputs.issueNumber || '' }}
      selectionLabel: ${{ inputs.selectionLabel || 'merged' }}
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}

  review-issue:
    needs:
      - select-issue
    if: ${{ needs.select-issue.outputs.issueNumber != '' && needs.select-issue.outputs.merged == 'true' }}
    permissions:
      contents: write
      issues: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-review-issue.yml@2.6.6'
    with:
      issueNumber: ${{ needs.select-issue.outputs.issueNumber }}
      target: ${{ inputs.target || 'src/lib/main.js' }}
      testFile: ${{ inputs.testFile || 'tests/unit/main.test.js' }}
      readmeFile: 'README.md'
      contributingFile: 'CONTRIBUTING.md'
      dependenciesFile: 'package.json'
      buildScript: 'npm run build'
      testScript: 'npm test'
      mainScript: ${{ vars.MAIN_SCRIPT || 'npm run start' }}
      model: ${{ vars.CHATGPT_API_MODEL || 'o3-mini' }}
    secrets:
      CHATGPT_API_SECRET_KEY: ${{ secrets.CHATGPT_API_SECRET_KEY }}
.github/workflows/formating.yml
==== Content of .github/workflows/formating.yml ====
# .github/workflows/formating.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: âˆž Formatting
concurrency: agentic-lib
run-name: "Formatting [${{ github.ref_name }}]"

on:
  workflow_dispatch:
  schedule:
    #- cron: '15 3 */7 * *' # schedule-1
    #- cron: '15 3 * * *' # schedule-2
    - cron: '15 3 * * *' # schedule-3

jobs:

  check-branch:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    env:
      branchPrefix: 'agentic-lib-'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}
      - name: Ensure there isn't already a branch for this prefix
        shell: bash
        run: |
          git fetch origin
          if git branch -r | grep -q 'origin/${{ env.branchPrefix }}'; then
            echo "A branch with the prefix '${{ env.branchPrefix }}' already exists."
            exit 1
          else
            echo "No existing branch with the prefix found."
          fi

  formatting:
    needs:
      - check-branch
    permissions:
      contents: write
      packages: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-run-script-and-commit-to-branch.yml@2.6.6'
    with:
      script: 'npm run formatting-fix -- src/lib/main.js tests/unit/main.test.js ; npm run linting-fix src/lib/main.js tests/unit/main.test.js'
      sarifScript: ''
      testScript: 'npm test'
      branch: 'agentic-lib-formatting'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
      gitCommitMessage: 'Updated by `npm run formatting-fix -- "." ; npm run linting-fix "."`'

  create-pr:
    needs:
      - formatting
    if: ${{ needs.formatting.outputs.updatedFiles == 'true' }}
    permissions:
      contents: write
      packages: write
      issues: write
      pull-requests: write
      checks: write
      id-token: write
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-create-pr.yml@2.6.6'
    with:
      branch: 'agentic-lib-formatting'
      baseBranch: 'main'
      gitCommitMessage: 'chore: formatting fixes'
      label: 'automerge'
.github/workflows/truncate-issue-history.yml
==== Content of .github/workflows/truncate-issue-history.yml ====
# .github/workflows/truncate-issue-history.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: âˆž Truncate Issue History
concurrency: truncate-issue-history

on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * *'

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Redact old GitHub issues and delete their comments
        uses: actions/github-script@v7
        with:
          script: |
            // Set retention period (in days)
            const retentionDays = 7;
            const cutoffDate = new Date(Date.now() - retentionDays * 24 * 60 * 60 * 1000);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const perPage = 100;
            let issuesRedacted = 0;
            let commentsDeleted = 0;

            console.log(`Redacting issues not updated in the last ${retentionDays} days (before ${cutoffDate.toISOString()})...`);

            let page = 1;
            while (true) {
              const issuesResponse = await github.rest.issues.listForRepo({
                owner,
                repo,
                state: 'all',
                per_page: perPage,
                page
              });
              const issues = issuesResponse.data;
              if (issues.length === 0) break;
              for (const issue of issues) {
                // Skip pull requests
                if (issue.pull_request) continue;
                const updatedAt = new Date(issue.updated_at);
                if (updatedAt < cutoffDate) {
                  try {
                    // Update the issue's title and body to "redact" details.
                    await github.rest.issues.update({
                      owner,
                      repo,
                      issue_number: issue.number,
                      title: "Redacted",
                      body: "This issue has been redacted."
                    });
                    console.log(`Redacted issue #${issue.number} (last updated at ${issue.updated_at})`);
                    issuesRedacted++;

                    // List and delete all comments for the issue.
                    let commentPage = 1;
                    while (true) {
                      const commentsResponse = await github.rest.issues.listComments({
                        owner,
                        repo,
                        issue_number: issue.number,
                        per_page: perPage,
                        page: commentPage
                      });
                      const comments = commentsResponse.data;
                      if (comments.length === 0) break;
                      for (const comment of comments) {
                        try {
                          await github.rest.issues.deleteComment({
                            owner,
                            repo,
                            comment_id: comment.id
                          });
                          console.log(`Deleted comment ${comment.id} on issue #${issue.number}`);
                          commentsDeleted++;
                        } catch (err) {
                          console.error(`Failed to delete comment ${comment.id} on issue #${issue.number}: ${err.message}`);
                        }
                      }
                      commentPage++;
                    }
                  } catch (error) {
                    console.error(`Failed to update issue #${issue.number}: ${error.message}`);
                  }
                }
              }
              page++;
            }
            console.log(`Total issues redacted: ${issuesRedacted}`);
            console.log(`Total comments deleted: ${commentsDeleted}`);
            return `Cleanup complete. Redacted ${issuesRedacted} issues and deleted ${commentsDeleted} comments.`;
          result-encoding: string
.github/dependabot.yml
==== Content of .github/dependabot.yml ====
# See: https://docs.github.com/code-security/dependabot/dependabot-version-updates/configuration-options-for-the-dependabot.yml-file
version: 2
updates:
  - package-ecosystem: "npm"
    directory: "/"
    schedule:
      interval: "weekly"
    labels:
      - dependencies
      - automated
    #ignore:
    #  - dependency-name: "some-dependency" # Example of ignoring a specific dependency
    #    versions: ["1.x", "2.x"]