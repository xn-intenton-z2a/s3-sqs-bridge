# .github/workflows/utils-seed-repository.yml
#
# This file is part of the example suite for `agentic-lib` see: https://github.com/xn-intenton-z2a/agentic-lib
# This file is licensed under the MIT License. For details, see LICENSE-MIT

name: seed-repository
concurrency: seed-repository
run-name: "seed repository"

on:
  workflow_dispatch:
    inputs:
      mission:
        description: 'The mission statement for the repository. e.g. "Be a go-to plot library with a CLI, be the jq of formulae visualisations.'
        required: false
        type: string
        default: ''
  schedule:
    - cron: '0 7 */7 * *' # schedule-1
    #- cron: '0 7 */7 * *' # schedule-2
    #- cron: '0 0 * * *' # schedule-3
    #- cron: '0 0 * * *' # schedule-4

env:
  mission: ${{ inputs.mission || '' }}
  gitUserEmail: 'action@github.com'
  gitUserName: 'GitHub Actions[bot]'
  archivePath: 'archive/'

jobs:

  agentic-lib:
    uses: 'xn-intenton-z2a/agentic-lib/.github/workflows/wfr-agent-config.yml@main'
    with:
      configPath: ${{ vars.configPath || '.github/agents/agentic-lib.yml' }}
    secrets:
      PERSONAL_ACCESS_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

  seed-repository:
    needs:
      - agentic-lib
    if: ${{ needs.agentic-lib.outputs.repositoryReseed == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0

      - name: archive
        id: archive
        shell: bash
        run: |
          intention="$(head -1 ${{ needs.agentic-lib.outputs.contributingFilepath }} | sed 's/^# //')"
          mkdir -p '${{ env.archivePath }}'
          cp -fv '${{ needs.agentic-lib.outputs.missionFilepath }}' "${{ env.archivePath }}${intention?}-$(date +%Y-%m-%d)-MISSION.md"
          cp -fv '${{ needs.agentic-lib.outputs.librarySourcesFilepath }}' "${{ env.archivePath }}${intention?}-$(date +%Y-%m-%d)-SOURCES.md"
          find '${{ needs.agentic-lib.outputs.libraryDocumentsPath }}' -maxdepth 2 -type f -name '*.md' -print -exec echo "# {}" \; -exec cat {} \; > "${{ env.archivePath }}${intention?}-$(date +%Y-%m-%d)-LIBRARY.md"
          find '${{ needs.agentic-lib.outputs.featuresPath }}' -maxdepth 2 -type f -name '*.md' -print -exec echo "# {}" \; -exec cat {} \; > "${{ env.archivePath }}${intention?}-$(date +%Y-%m-%d)-FEATURES.md"
          find '${{ needs.agentic-lib.outputs.targetTestsPath }}' -maxdepth 2 -type f -name '*.js' -print -exec echo "# {}" \; -exec cat {} \; > "${{ env.archivePath }}${intention?}-$(date +%Y-%m-%d)-tests.txt"
          find '${{ needs.agentic-lib.outputs.targetSourcePath }}' -maxdepth 2 -type f -name '*.js' -print -exec echo "# {}" \; -exec cat {} \; > "${{ env.archivePath }}${intention?}-$(date +%Y-%m-%d)-source.txt"
          cp -fv '${{ needs.agentic-lib.outputs.dependenciesFilepath }}' "${{ env.archivePath }}${intention?}-$(date +%Y-%m-%d)-package.json"
          find '${{ needs.agentic-lib.outputs.documentationPath }}' -maxdepth 2 -type f -name '*.md' -print -exec echo "# {}" \; -exec cat {} \; > "${{ env.archivePath }}${intention?}-$(date +%Y-%m-%d)-DOCS.md"
          cp -fv '${{ needs.agentic-lib.outputs.readmeFilepath }}' "${{ env.archivePath }}${intention?}-$(date +%Y-%m-%d)-README.md"

      - name: empty-library-sources
        id: empty-library-sources
        shell: bash
        run: |
          rm -rvf '${{ needs.agentic-lib.outputs.librarySourcesPath }}/*'
          echo "Library sources emptied from ${{ needs.agentic-lib.outputs.librarySourcesPath }}."

      - name: empty-library-documents
        id: empty-library-documents
        shell: bash
        run: |
          rm -rvf '${{ needs.agentic-lib.outputs.libraryDocumentsPath }}/*'
          echo "Library documents emptied from ${{ needs.agentic-lib.outputs.libraryDocumentsPath }}."

      - name: empty-features
        id: empty-features
        shell: bash
        run: |
          rm -rvf '${{ needs.agentic-lib.outputs.featuresPath }}/*'
          echo "Features emptied from ${{ needs.agentic-lib.outputs.featuresPath }}."

      - name: empty-target-source
        id: empty-target-source
        shell: bash
        run: |
          rm -rvf '${{ needs.agentic-lib.outputs.targetSourcePath }}/*'
          echo "Target source emptied from ${{ needs.agentic-lib.outputs.targetSourcePath }}."

      - name: empty-target-tests
        id: empty-target-tests
        shell: bash
        run: |
          rm -rvf '${{ needs.agentic-lib.outputs.targetTestsPath }}/*'
          echo "Target tests emptied from ${{ needs.agentic-lib.outputs.targetTestsPath }}."

      - name: empty-docs
        id: empty-docs
        shell: bash
        run: |
          rm -rvf '${{ needs.agentic-lib.outputs.documentationPath }}/*'
          echo "Documentation emptied from ${{ needs.agentic-lib.outputs.documentationPath }}."

      - name: seed-repository
        id: seed-repository
        shell: bash
        run: |
            if [[ '${{ needs.agentic-lib.outputs.targetSourcePath }}' == */ ]]; then
              mkdir -p '${{ needs.agentic-lib.outputs.targetSourcePath }}'
            else
              mkdir -p "$(dirname '${{ needs.agentic-lib.outputs.targetSourcePath }}')"
            fi
            cp -vf '${{ needs.agentic-lib.outputs.repositoryReseedSourcePath }}' '${{ needs.agentic-lib.outputs.targetSourcePath }}/main.js'
            echo 'Seeded repository from ${{ needs.agentic-lib.outputs.repositoryReseedSourcePath }} to ${{ needs.agentic-lib.outputs.targetSourcePath }}/.'
          
            if [[ '${{ needs.agentic-lib.outputs.targetTestsPath }}' == */ ]]; then
              mkdir -p '${{ needs.agentic-lib.outputs.targetTestsPath }}'
            else
              mkdir -p "$(dirname '${{ needs.agentic-lib.outputs.targetTestsPath }}')"
            fi
            cp -vf '${{ needs.agentic-lib.outputs.repositoryReseedTestsPath }}' '${{ needs.agentic-lib.outputs.targetTestsPath }}/main.test.js'
            echo 'Seeded repository from ${{ needs.agentic-lib.outputs.repositoryReseedTestsPath }} to ${{ needs.agentic-lib.outputs.targetTestsPath }}/.'
          
            mkdir -p "$(dirname '${{ needs.agentic-lib.outputs.readmeFilepath }}')"
            cp -vf '${{ needs.agentic-lib.outputs.repositoryReseedReadmeFilepath }}' '${{ needs.agentic-lib.outputs.readmeFilepath }}'
            echo 'Seeded repository from ${{ needs.agentic-lib.outputs.repositoryReseedReadmeFilepath }} to ${{ needs.agentic-lib.outputs.readmeFilepath }}'
            
            cp -vf '${{ needs.agentic-lib.outputs.repositoryReseedDependenciesFilepath }}' '${{ needs.agentic-lib.outputs.dependenciesFilepath }}'
            echo 'Seeded repository from ${{ needs.agentic-lib.outputs.repositoryReseedDependenciesFilepath }} to ${{ needs.agentic-lib.outputs.dependenciesFilepath }}'
            
            # If the mission is set, create a mission out of that text, else if the mission is not set use the config.
            mkdir -p "$(dirname '${{ needs.agentic-lib.outputs.missionFilepath }}')"
            if [ -n '${{ env.mission }}' ]; then
              echo "# ${GITHUB_REPOSITORY}" > '${{ needs.agentic-lib.outputs.missionFilepath }}'
              echo '${{ env.mission }}' >> '${{ needs.agentic-lib.outputs.missionFilepath }}'
              echo "Seeded repository from '${{ env.mission }}' to ${{ needs.agentic-lib.outputs.missionFilepath }}."
            else
              cp -rvf '${{ needs.agentic-lib.outputs.repositoryReseedMissionFilepath }}' '${{ needs.agentic-lib.outputs.missionFilepath }}/.'
              echo 'Seeded repository from ${{ needs.agentic-lib.outputs.repositoryReseedMissionFilepath }} to ${{ needs.agentic-lib.outputs.missionFilepath }}/.'
            fi

      - name: Commit and push
        id: commit
        continue-on-error: true
        run: |
          git config --local user.email '${{ env.gitUserEmail }}'
          git config --local user.name '${{ env.gitUserName }}'
          git status -v
          git add -v --all
          git diff
          git commit -m 'Reseed repository' --allow-empty
          git push -v
          git status -v

  delete-branches:
    needs:
      - agentic-lib
    if: ${{ needs.agentic-lib.outputs.repositoryReseed == 'true' }}
    runs-on: ubuntu-latest
    env:
      branchPrefix: 'agentic-lib-'
      gitUserEmail: 'action@github.com'
      gitUserName: 'GitHub Actions[bot]'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch all branches
        run: |
          git fetch --all
          git branch -r

      - name: delete branches matching ${{ env.branchPrefix }}
        id: determine
        uses: actions/github-script@v7
        env:
          attemptsPerBranch: ${{ needs.agentic-lib.outputs.attemptsPerBranch }}
        with:
          script: |
            const gitUserEmail = process.env.gitUserEmail;
            const gitUserName = process.env.gitUserName;
            const { execSync } = require('child_process');
            const prefix = process.env.branchPrefix || "agentic-lib-";

            let branch;
            core.info("Schedule event detected. Scanning for matching branches.");
            const branchesResp = await github.rest.repos.listBranches({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            const matchingBranches = branchesResp.data
              .filter(b => new RegExp(`^${prefix}`).test(b.name))
              .map(b => b.name);
            core.info(`Matching branches: ${matchingBranches}`);

            // Check if any of the matching branches have a PR open
            const openPRs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
            });

            // Close any open PRs for the matching branches
            for (const pr of openPRs.data) {
              if (matchingBranches.includes(pr.head.ref)) {
                core.info(`Reset sandbox: Closing PR #${pr.number} for branch ${pr.head.ref}`);
                await github.rest.pulls.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  state: 'closed',
                });
              }
            }
            
            // Delete the branches
            for (const branch of matchingBranches) {
              core.info(`Reset sandbox: Deleting branch ${branch}`);
              try {
                execSync(`git push origin --delete ${branch}`, { stdio: 'inherit' });
                core.info(`Deleted branch ${branch}`);
              } catch (error) {
                core.error(`Failed to delete branch ${branch}: ${error.message}`);
              }
            }

    outputs:
      branch: ${{ steps.determine.outputs.branch }}

  cleanup-issues:
    needs:
      - agentic-lib
    if: ${{ needs.agentic-lib.outputs.repositoryReseed == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Redact old GitHub issues and delete their comments
        uses: actions/github-script@v7
        with:
          script: |
            // Set retention period (in days)
            const retentionDays = 0;
            const cutoffDate = new Date(Date.now() - retentionDays * 24 * 60 * 60 * 1000);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const perPage = 100;

            console.log(`Closing issues not updated in the last ${retentionDays} days (before ${cutoffDate.toISOString()})...`);

            let page = 1;
            while (true) {
              const issuesResponse = await github.rest.issues.listForRepo({
                owner,
                repo,
                state: 'all',
                per_page: perPage,
                state: 'open',
                page
              });
              const issues = issuesResponse.data;
              if (!issues || issues.length === 0) break;
              for (const issue of issues) {
                // Skip pull requests
                if (issue.pull_request) continue;
                const updatedAt = new Date(issue.updated_at);
                if (updatedAt < cutoffDate) {
                  try {
                    // Close the issue
                    await github.rest.issues.update({
                      owner,
                      repo,
                      issue_number: issue.number,
                      state: 'closed',
                    });
                    core.info(`Closed issue #${issue.number} (${issue.title})`);
                  } catch (error) {
                    console.error(`Failed to close issue #${issue.number}: ${error.message}`);
                  }
                }
              }
              page++;
            }
